{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Contribution Guide","text":"<p>Everyone can contribute to help other developers utilize this documentation for their learning and to improve their programming skills.</p>"},{"location":"#naming-convention-for-filenames","title":"Naming Convention for filenames","text":"<ol> <li>Lowercase Letters: Use lowercase letters to maintain consistency and avoid issues in case-sensitive file systems.</li> <li> <p>Example: <code>frontend-engineering.md</code></p> </li> <li> <p>Hyphens for Spaces: Use hyphens to separate words instead of spaces or underscores. This improves readability and avoids issues with URLs.</p> </li> <li> <p>Example: <code>learning-and-development.md</code></p> </li> <li> <p>Descriptive Names: Use descriptive names that clearly indicate the content of the file.</p> </li> <li> <p>Example: <code>introduction-to-css.md</code></p> </li> <li> <p>Avoid Special Characters: Avoid using special characters except for hyphens. This prevents potential issues with different operating systems.</p> </li> <li> <p>Example: <code>setup-guide.md</code></p> </li> <li> <p>Versioning: If versioning is necessary, include the version number at the end of the file name.</p> </li> <li> <p>Example: <code>api-documentation-v1.0.md</code></p> </li> <li> <p>Dates: If including dates, use the ISO format (YYYY-MM-DD) for clarity and sorting purposes.</p> </li> <li>Example: <code>release-notes-2024-07-06.md</code></li> </ol> <p>Following these guidelines, some examples of Markdown file names are:</p> <ul> <li><code>getting-started.md</code></li> <li><code>frontend-best-practices.md</code></li> <li><code>responsive-design.md</code></li> <li><code>javascript-fundamentals.md</code></li> <li><code>css-tips-and-tricks.md</code></li> </ul> <p>Home</p>"},{"location":"design-pattern/","title":"\ud83d\udcc4 Design Pattern","text":""},{"location":"design-pattern/#singleton","title":"Singleton","text":"<pre><code>class Singleton {\n  static instance;\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new Singleton();\n    }\n    return this.instance;\n  }\n}\n</code></pre> <pre><code>class Singleton {\n  static instance;\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new Singleton();\n    }\n    return this.instance;\n  }\n}\n\nconst singleton1 = Singleton.getInstance();\nconst singleton2 = Singleton.getInstance();\nconsole.log(singleton1 === singleton2); // true\n</code></pre> Use Case Cons When a single instance of a class is needed across the application. Challenging to unit test, issues in multithreading."},{"location":"design-pattern/#factory-method","title":"Factory Method","text":"<pre><code>class ProductFactory {\n  createProduct(type) {\n    if (type === 'A') return new ProductA();\n    if (type === 'B') return new ProductB();\n  }\n}\n</code></pre> <pre><code>class ProductA {\n  create() {\n    console.log('Product A created');\n  }\n}\n\nclass ProductB {\n  create() {\n    console.log('Product B created');\n  }\n}\n\nclass ProductFactory {\n  createProduct(type) {\n    if (type === 'A') return new ProductA();\n    if (type === 'B') return new ProductB();\n  }\n}\n\nconst factory = new ProductFactory();\nconst productA = factory.createProduct('A');\nproductA.create(); // Product A created\n\nconst productB = factory.createProduct('B');\nproductB.create(); // Product B created\n</code></pre> Use Case Cons When a class cannot anticipate the class of objects it must create. Increases complexity with an extra class for each product."},{"location":"design-pattern/#abstract-factory","title":"Abstract Factory","text":"<pre><code>class GUIFactory {\n  createButton();\n  createCheckbox();\n}\nclass WinFactory extends GUIFactory {\n  createButton() { return new WinButton(); }\n  createCheckbox() { return new WinCheckbox(); }\n}\n</code></pre> <pre><code>class Button {\n  paint() {}\n}\n\nclass WinButton extends Button {\n  paint() {\n    console.log('Rendering a button in a Windows style');\n  }\n}\n\nclass MacButton extends Button {\n  paint() {\n    console.log('Rendering a button in a macOS style');\n  }\n}\n\nclass Checkbox {\n  paint() {}\n}\n\nclass WinCheckbox extends Checkbox {\n  paint() {\n    console.log('Rendering a checkbox in a Windows style');\n  }\n}\n\nclass MacCheckbox extends Checkbox {\n  paint() {\n    console.log('Rendering a checkbox in a macOS style');\n  }\n}\n\nclass GUIFactory {\n  createButton() {}\n  createCheckbox() {}\n}\n\nclass WinFactory extends GUIFactory {\n  createButton() {\n    return new WinButton();\n  }\n  createCheckbox() {\n    return new WinCheckbox();\n  }\n}\n\nclass MacFactory extends GUIFactory {\n  createButton() {\n    return new MacButton();\n  }\n  createCheckbox() {\n    return new MacCheckbox();\n  }\n}\n\nfunction getFactory(osType) {\n  if (osType === 'Windows') {\n    return new WinFactory();\n  } else if (osType === 'macOS') {\n    return new MacFactory();\n  }\n}\n\nconst factory = getFactory('Windows');\nconst button = factory.createButton();\nbutton.paint(); // Rendering a button in a Windows style\nconst checkbox = factory.createCheckbox();\ncheckbox.paint(); // Rendering a checkbox in a Windows style\n</code></pre> Use Case Cons When families of related objects need to be created without specifying their concrete classes. Difficult to extend with new product families."},{"location":"design-pattern/#builder","title":"Builder","text":"<pre><code>class ProductBuilder {\n  setPartA(value) { this.partA = value; return this; }\n  setPartB(value) { this.partB = value; return this; }\n  build() { return new Product(this); }\n}\n</code></pre> <pre><code>class Product {\n  constructor(builder) {\n    this.partA = builder.partA;\n    this.partB = builder.partB;\n  }\n}\n\nclass ProductBuilder {\n  setPartA(value) {\n    this.partA = value;\n    return this;\n  }\n  setPartB(value) {\n    this.partB = value;\n    return this;\n  }\n  build() {\n    return new Product(this);\n  }\n}\n\nconst builder = new ProductBuilder();\nconst product = builder.setPartA('Value A').setPartB('Value B').build();\nconsole.log(product);\n</code></pre> Use Case Cons When constructing complex objects step by step is required. Increased complexity with the necessity of a builder class."},{"location":"design-pattern/#prototype","title":"Prototype","text":"<pre><code>class Prototype {\n  clone() { return Object.assign({}, this); }\n}\n</code></pre> <pre><code>class Prototype {\n  constructor(name) {\n    this.name = name;\n  }\n\n  clone() {\n    return new Prototype(this.name);\n  }\n}\n\nconst original = new Prototype('Original');\nconst copy = original.clone();\nconsole.log(copy.name); // Original\n</code></pre> Use Case Cons When instances of a class can have one of only a few different combinations of state. Cloning complex objects with circular references can be challenging"},{"location":"design-pattern/#adapter","title":"Adapter","text":"<pre><code>class OldSystem {\n  oldMethod() {}\n}\nclass Adapter {\n  constructor(oldSystem) { this.oldSystem = oldSystem; }\n  newMethod() { this.oldSystem.oldMethod(); }\n}\n</code></pre> <pre><code>class OldSystem {\n  oldMethod() {\n    console.log('Old system method');\n  }\n}\n\nclass Adapter {\n  constructor(oldSystem) {\n    this.oldSystem = oldSystem;\n  }\n\n  newMethod() {\n    this.oldSystem.oldMethod();\n  }\n}\n\nconst oldSystem = new OldSystem();\nconst adapter = new Adapter(oldSystem);\nadapter.newMethod(); // Old system method\n</code></pre> Use Case Cons When the interface of an existing class needs to be adapted to another interface. Can lead to excessive use of objects."},{"location":"design-pattern/#bridge","title":"Bridge","text":"<pre><code>class Abstraction {\n  constructor(implementor) { this.implementor = implementor; }\n  operation() { this.implementor.operationImpl(); }\n}\n</code></pre> <pre><code>class Implementor {\n  operationImpl() {}\n}\n\nclass ConcreteImplementorA extends Implementor {\n  operationImpl() {\n    console.log('Concrete Implementor A');\n  }\n}\n\nclass ConcreteImplementorB extends Implementor {\n  operationImpl() {\n    console.log('Concrete Implementor B');\n  }\n}\n\nclass Abstraction {\n  constructor(implementor) {\n    this.implementor = implementor;\n  }\n\n  operation() {\n    this.implementor.operationImpl();\n  }\n}\n\nconst implementorA = new ConcreteImplementorA();\nconst abstractionA = new Abstraction(implementorA);\nabstractionA.operation(); // Concrete Implementor A\n\nconst implementorB = new ConcreteImplementorB();\nconst abstractionB = new Abstraction(implementorB);\nabstractionB.operation(); // Concrete Implementor B\n</code></pre> Use Case Cons When you need to separate an object\u2019s abstraction from its implementation. Can increase complexity with two layers of abstraction."},{"location":"design-pattern/#composite","title":"Composite","text":"<pre><code>class Component {\n  operation() {}\n}\nclass Composite extends Component {\n  constructor() { this.children = []; }\n  add(child) { this.children.push(child); }\n  operation() { this.children.forEach(child =&gt; child.operation()); }\n}\n</code></pre> <pre><code>class Component {\n  operation() {}\n}\n\nclass Leaf extends Component {\n  operation() {\n    console.log('Leaf operation');\n  }\n}\n\nclass Composite extends Component {\n  constructor() {\n    super();\n    this.children = [];\n  }\n\n  add(child) {\n    this.children.push(child);\n  }\n\n  operation() {\n    this.children.forEach(child =&gt; child.operation());\n  }\n}\n\nconst leaf1 = new Leaf();\nconst leaf2 = new Leaf();\nconst composite = new Composite();\ncomposite.add(leaf1);\ncomposite.add(leaf2);\ncomposite.operation();\n// Leaf operation\n// Leaf operation\n</code></pre> Use Case Cons When objects need to be composed into tree structures to represent part-whole hierarchies. Can make the system overly general."},{"location":"design-pattern/#decorator","title":"Decorator","text":"<pre><code>class Component {\n  operation() {}\n}\nclass Decorator extends Component {\n  constructor(component) { this.component = component; }\n  operation() { this.component.operation(); }\n}\n</code></pre> <pre><code>class Component {\n  operation() {}\n}\n\nclass ConcreteComponent extends Component {\n  operation() {\n    console.log('ConcreteComponent operation');\n  }\n}\n\nclass Decorator extends Component {\n  constructor(component) {\n    super();\n    this.component = component;\n  }\n\n  operation() {\n    this.component.operation();\n  }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n  operation() {\n    super.operation();\n    console.log('ConcreteDecoratorA operation');\n  }\n}\n\nconst component = new ConcreteComponent();\nconst decorator = new ConcreteDecoratorA(component);\ndecorator.operation();\n// ConcreteComponent operation\n// ConcreteDecoratorA operation\n</code></pre> Use Case Cons When behavior should be added to objects dynamically. Can lead to a large number of small classes."},{"location":"design-pattern/#facade","title":"Facade","text":"<pre><code>class Facade {\n  operation() {\n    subsystem1.operation();\n    subsystem2.operation();\n  }\n}\n</code></pre> <pre><code>class Subsystem1 {\n  operation() {\n    console.log('Subsystem1 operation');\n  }\n}\n\nclass Subsystem2 {\n  operation() {\n    console.log('Subsystem2 operation');\n  }\n}\n\nclass Facade {\n  constructor() {\n    this.subsystem1 = new Subsystem1();\n    this.subsystem2 = new Subsystem2();\n  }\n\n  operation() {\n    this.subsystem1.operation();\n    this.subsystem2.operation();\n  }\n}\n\nconst facade = new Facade();\nfacade.operation();\n// Subsystem1 operation\n// Subsystem2 operation\n</code></pre> Use Case Cons When a simple interface to a complex subsystem is needed. Can become a god object that knows too much or does too much."},{"location":"design-pattern/#flyweight","title":"Flyweight","text":"<pre><code>class Flyweight {\n  constructor(sharedState) { this.sharedState = sharedState; }\n  operation(uniqueState) {}\n}\nclass FlyweightFactory {\n  getFlyweight(sharedState) {\n    if (!this.flyweights[sharedState]) {\n      this.flyweights[sharedState] = new Flyweight(sharedState);\n    }\n    return this.flyweights[sharedState];\n  }\n}\n</code></pre> <pre><code>class Flyweight {\n  constructor(sharedState) {\n    this.sharedState = sharedState;\n  }\n\n  operation(uniqueState) {\n    console.log(`Flyweight: shared=${this.sharedState}, unique=${uniqueState}`);\n  }\n}\n\nclass FlyweightFactory {\n  constructor() {\n    this.flyweights = {};\n  }\n\n  getFlyweight(sharedState) {\n    if (!this.flyweights[sharedState]) {\n      this.flyweights[sharedState] = new Flyweight(sharedState);\n    }\n    return this.flyweights[sharedState];\n  }\n}\n\nconst factory = new FlyweightFactory();\nconst flyweight1 = factory.getFlyweight('shared');\nflyweight1.operation('unique1');\nconst flyweight2 = factory.getFlyweight('shared');\nflyweight2.operation('unique2');\n// Flyweight: shared=shared, unique=unique1\n// Flyweight: shared=shared, unique=unique2\n</code></pre> Use Case Cons When a large number of similar objects are needed. Complex to implement, needs careful management of shared state."},{"location":"design-pattern/#proxy","title":"Proxy","text":"<pre><code>class Proxy {\n  constructor(realSubject) { this.realSubject = realSubject; }\n  request() { this.realSubject.request(); }\n}\n</code></pre> <pre><code>class RealSubject {\n  request() {\n    console.log('RealSubject request');\n  }\n}\n\nclass Proxy {\n  constructor(realSubject) {\n    this.realSubject = realSubject;\n  }\n\n  request() {\n    console.log('Proxy request');\n    this.realSubject.request();\n  }\n}\n\nconst realSubject = new RealSubject();\nconst proxy = new Proxy(realSubject);\nproxy.request();\n// Proxy request\n// RealSubject request\n</code></pre> Use Case Cons When a placeholder or proxy for another object is required to control access. Can introduce latency."},{"location":"design-pattern/#chain-of-responsibility","title":"Chain of Responsibility","text":"<pre><code>class Handler {\n  setNext(handler) { this.next = handler; return handler; }\n  handle(request) {\n    if (this.next) { return this.next.handle(request); }\n    return null;\n  }\n}\n</code></pre> <pre><code>class Handler {\n  setNext(handler) {\n    this.next = handler;\n    return handler;\n  }\n\n  handle(request) {\n    if (this.next) {\n      return this.next.handle(request);\n    }\n    return null;\n  }\n}\n\nclass ConcreteHandler1 extends Handler {\n  handle(request) {\n    if (request === 'request1') {\n      console.log('ConcreteHandler1 handled request1');\n    } else {\n      super.handle(request);\n    }\n  }\n}\n\nclass ConcreteHandler2 extends Handler {\n  handle(request) {\n    if (request === 'request2') {\n      console.log('ConcreteHandler2 handled request2');\n    } else {\n      super.handle(request);\n    }\n  }\n}\n\nconst handler1 = new ConcreteHandler1();\nconst handler2 = new ConcreteHandler2();\nhandler1.setNext(handler2);\n\nhandler1.handle('request1'); // ConcreteHandler1 handled request1\nhandler1.handle('request2'); // ConcreteHandler2 handled request2\n</code></pre> Use Case Cons When multiple objects can handle a request, but the handler isn\u2019t known beforehand. Hard to observe the flow of the request."},{"location":"design-pattern/#command","title":"Command","text":"<pre><code>class Command {\n  execute() {}\n}\nclass Invoker {\n  setCommand(command) { this.command = command; }\n  executeCommand() { this.command.execute(); }\n}\n</code></pre> <pre><code>class Command {\n  execute() {}\n}\n\nclass ConcreteCommand extends Command {\n  constructor(receiver) {\n    super();\n    this.receiver = receiver;\n  }\n\n  execute() {\n    this.receiver.action();\n  }\n}\n\nclass Receiver {\n  action() {\n    console.log('Receiver action');\n  }\n}\n\nclass Invoker {\n  setCommand(command) {\n    this.command = command;\n  }\n\n  executeCommand() {\n    this.command.execute();\n  }\n}\n\nconst receiver = new Receiver();\nconst command = new ConcreteCommand(receiver);\nconst invoker = new Invoker();\ninvoker.setCommand(command);\ninvoker.executeCommand(); // Receiver action\n</code></pre> Use Case Cons When parameterize objects with operations is required. Can result in a large number of command classes."},{"location":"design-pattern/#interpreter","title":"Interpreter","text":"<pre><code>class Expression {\n  interpret(context) {}\n}\nclass TerminalExpression extends Expression {\n  interpret(context) {\n    // implementation\n  }\n}\n</code></pre> <pre><code>class Expression {\n  interpret(context) {}\n}\n\nclass TerminalExpression extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  interpret(context) {\n    return context.includes(this.value);\n  }\n}\n\nclass OrExpression extends Expression {\n  constructor(expr1, expr2) {\n    super();\n    this.expr1 = expr1;\n    this.expr2 = expr2;\n  }\n\n  interpret(context) {\n    return this.expr1.interpret(context) || this.expr2.interpret(context);\n  }\n}\n\nconst expr1 = new TerminalExpression('Hello');\nconst expr2 = new TerminalExpression('World');\nconst orExpr = new OrExpression(expr1, expr2);\n\nconst context = 'Hello everyone';\nconsole.log(orExpr.interpret(context)); // true\n</code></pre> Use Case Cons When the grammar of a language needs to be interpreted. Complex grammars can be hard to manage and slow to execute."},{"location":"design-pattern/#iterator","title":"Iterator","text":"<pre><code>class Iterator {\n  next() {}\n  hasNext() {}\n}\nclass Aggregate {\n  createIterator() { return new Iterator(); }\n}\n</code></pre> <pre><code>class Iterator {\n  constructor(collection) {\n    this.collection = collection;\n    this.index = 0;\n  }\n\n  next() {\n    return this.collection[this.index++];\n  }\n\n  hasNext() {\n    return this.index &lt; this.collection.length;\n  }\n}\n\nclass Aggregate {\n  constructor() {\n    this.items = [];\n  }\n\n  add(item) {\n    this.items.push(item);\n  }\n\n  createIterator() {\n    return new Iterator(this.items);\n  }\n}\n\nconst aggregate = new Aggregate();\naggregate.add('Item 1');\naggregate.add('Item 2');\n\nconst iterator = aggregate.createIterator();\nwhile (iterator.hasNext()) {\n  console.log(iterator.next());\n}\n// Item 1\n// Item 2\n</code></pre> Use Case Cons When sequential access to elements of a collection is needed without exposing its underlying representation. Might not be optimal for large collections."},{"location":"design-pattern/#mediator","title":"Mediator","text":"<pre><code>class Mediator {\n  notify(sender, event) {}\n}\nclass Component {\n  constructor(mediator) { this.mediator = mediator; }\n}\n</code></pre> <pre><code>class Mediator {\n  notify(sender, event) {\n    if (event === 'A') {\n      console.log('Mediator reacts on A and triggers the following operations:');\n      this.component2.doC();\n    }\n    if (event === 'D') {\n      console.log('Mediator reacts on D and triggers the following operations:');\n      this.component1.doB();\n      this.component2.doC();\n    }\n  }\n}\n\nclass Component1 {\n  constructor(mediator) {\n    this.mediator = mediator;\n  }\n\n  doA() {\n    console.log('Component 1 does A.');\n    this.mediator.notify(this, 'A');\n  }\n\n  doB() {\n    console.log('Component 1 does B.');\n    this.mediator.notify(this, 'B');\n  }\n}\n\nclass Component2 {\n  constructor(mediator) {\n    this.mediator = mediator;\n  }\n\n  doC() {\n    console.log('Component 2 does C.');\n    this.mediator.notify(this, 'C');\n  }\n\n  doD() {\n    console.log('Component 2 does D.');\n    this.mediator.notify(this, 'D');\n  }\n}\n\nconst mediator = new Mediator();\nconst component1 = new Component1(mediator);\nconst component2 = new Component2(mediator);\n\nmediator.component1 = component1;\nmediator.component2 = component2;\n\ncomponent1.doA();\n// Component 1 does A.\n// Mediator reacts on A and triggers the following operations:\n// Component 2 does C.\n\ncomponent2.doD();\n// Component 2 does D.\n// Mediator reacts on D and triggers the following operations:\n// Component 1 does B.\n// Component 2 does C.\n</code></pre> Use Case Cons When reducing the complexity of communication between multiple objects is needed. Can become a complex god object."},{"location":"design-pattern/#memento","title":"Memento","text":"<pre><code>class Memento {\n  constructor(state) { this.state = state; }\n  getState() { return this.state; }\n}\nclass Originator {\n  setState(state) { this.state = state; }\n  createMemento() { return new Memento(this.state); }\n  restore(memento) { this.state = memento.getState(); }\n}\n</code></pre> <pre><code>class Memento {\n  constructor(state) {\n    this.state = state;\n  }\n\n  getState() {\n    return this.state;\n  }\n}\n\nclass Originator {\n  setState(state) {\n    console.log(`Originator: Setting state to ${state}`);\n    this.state = state;\n  }\n\n  saveStateToMemento() {\n    console.log(`Originator: Saving state to Memento`);\n    return new Memento(this.state);\n  }\n\n  getStateFromMemento(memento) {\n    this.state = memento.getState();\n    console.log(`Originator: State after restoring from Memento: ${this.state}`);\n  }\n}\n\nclass Caretaker {\n  constructor() {\n    this.mementoList = [];\n  }\n\n  add(state) {\n    this.mementoList.push(state);\n  }\n\n  get(index) {\n    return this.mementoList[index];\n  }\n}\n\nconst originator = new Originator();\nconst caretaker = new Caretaker();\n\noriginator.setState(\"State #1\");\noriginator.setState(\"State #2\");\ncaretaker.add(originator.saveStateToMemento());\n\noriginator.setState(\"State #3\");\ncaretaker.add(originator.saveStateToMemento());\n\noriginator.setState(\"State #4\");\n\nconsole.log(`Current State: ${originator.state}`);\n\noriginator.getStateFromMemento(caretaker.get(0));\noriginator.getStateFromMemento(caretaker.get(1));\n</code></pre> Use Case Cons When capturing and restoring an object\u2019s internal state is required. Can lead to high memory usage."},{"location":"design-pattern/#observer","title":"Observer","text":"<pre><code>class Observer {\n  update(subject) {}\n}\nclass Subject {\n  attach(observer) { this.observers.push(observer); }\n  notify() { this.observers.forEach(observer =&gt; observer.update(this)); }\n}\n</code></pre> <pre><code>class Subject {\n  constructor() {\n    this.observers = [];\n  }\n\n  attach(observer) {\n    this.observers.push(observer);\n  }\n\n  detach(observer) {\n    this.observers = this.observers.filter(obs =&gt; obs !== observer);\n  }\n\n  notify() {\n    this.observers.forEach(observer =&gt; observer.update());\n  }\n}\n\nclass Observer {\n  constructor(name) {\n    this.name = name;\n  }\n\n  update() {\n    console.log(`${this.name} has been notified`);\n  }\n}\n\nconst subject = new Subject();\n\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\n\nsubject.attach(observer1);\nsubject.attach(observer2);\n\nsubject.notify();\n// Observer 1 has been notified\n// Observer 2 has been notified\n</code></pre> Use Case Cons When an object needs to notify multiple observers about state changes. Can lead to memory leaks with improper management."},{"location":"design-pattern/#state","title":"State","text":"<pre><code>class State {\n  handle(context) {}\n}\nclass Context {\n  setState(state) { this.state = state; }\n  request() { this.state.handle(this); }\n}\n</code></pre> <pre><code>class State {\n  handle(context) {}\n}\n\nclass ConcreteStateA extends State {\n  handle(context) {\n    console.log('ConcreteStateA handles request.');\n    context.state = new ConcreteStateB();\n  }\n}\n\nclass ConcreteStateB extends State {\n  handle(context) {\n    console.log('ConcreteStateB handles request.');\n    context.state = new ConcreteStateA();\n  }\n}\n\nclass Context {\n  constructor() {\n    this.state = new ConcreteStateA();\n  }\n\n  request() {\n    this.state.handle(this);\n  }\n}\n\nconst context = new Context();\ncontext.request(); // ConcreteStateA handles request.\ncontext.request(); // ConcreteStateB handles request.\ncontext.request(); // ConcreteStateA handles request.\n</code></pre> Use Case Cons When an object\u2019s behavior depends on its state. Can increase the number of classes and complexity."},{"location":"design-pattern/#strategy","title":"Strategy","text":"<pre><code>class Strategy {\n  execute() {}\n}\nclass Context {\n  setStrategy(strategy) { this.strategy = strategy; }\n  executeStrategy() { this.strategy.execute(); }\n}\n</code></pre> <pre><code>class Strategy {\n  execute() {}\n}\n\nclass ConcreteStrategyA extends Strategy {\n  execute() {\n    console.log('Strategy A');\n  }\n}\n\nclass ConcreteStrategyB extends Strategy {\n  execute() {\n    console.log('Strategy B');\n  }\n}\n\nclass Context {\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeStrategy() {\n    this.strategy.execute();\n  }\n}\n\nconst context = new Context();\ncontext.setStrategy(new ConcreteStrategyA());\ncontext.executeStrategy(); // Strategy A\n\ncontext.setStrategy(new ConcreteStrategyB());\ncontext.executeStrategy(); // Strategy B\n</code></pre> Use Case Cons When different algorithms can be used interchangeably. Clients must be aware of different strategies."},{"location":"design-pattern/#template-method","title":"Template Method","text":"<pre><code>class AbstractClass {\n  templateMethod() {\n    this.step1();\n    this.step2();\n  }\n  step1() {}\n  step2() {}\n}\nclass ConcreteClass extends AbstractClass {\n  step1() {\n    // implementation\n  }\n  step2() {\n    // implementation\n  }\n}\n</code></pre> <pre><code>class AbstractClass {\n  templateMethod() {\n    this.baseOperation1();\n    this.requiredOperation1();\n    this.baseOperation2();\n    this.hook1();\n    this.requiredOperation2();\n    this.baseOperation3();\n    this.hook2();\n  }\n\n  baseOperation1() {\n    console.log('AbstractClass says: I am doing the bulk of the work');\n  }\n\n  baseOperation2() {\n    console.log('AbstractClass says: But I let subclasses override some operations');\n  }\n\n  baseOperation3() {\n    console.log('AbstractClass says: But I am doing the bulk of the work anyway');\n  }\n\n  requiredOperation1() {}\n  requiredOperation2() {}\n\n  hook1() {}\n  hook2() {}\n}\n\nclass ConcreteClass1 extends AbstractClass {\n  requiredOperation1() {\n    console.log('ConcreteClass1 says: Implemented Operation1');\n  }\n\n  requiredOperation2() {\n    console.log('ConcreteClass1 says: Implemented Operation2');\n  }\n}\n\nclass ConcreteClass2 extends AbstractClass {\n  requiredOperation1() {\n    console.log('ConcreteClass2 says: Implemented Operation1');\n  }\n\n  requiredOperation2() {\n    console.log('ConcreteClass2 says: Implemented Operation2');\n  }\n\n  hook1() {\n    console.log('ConcreteClass2 says: Overridden Hook1');\n  }\n}\n\nconst concreteClass1 = new ConcreteClass1();\nconcreteClass1.templateMethod();\n// AbstractClass says: I am doing the bulk of the work\n// ConcreteClass1 says: Implemented Operation1\n// AbstractClass says: But I let subclasses override some operations\n// AbstractClass says: But I am doing the bulk of the work anyway\n// ConcreteClass1 says: Implemented Operation2\n\nconst concreteClass2 = new ConcreteClass2();\nconcreteClass2.templateMethod();\n// AbstractClass says: I am doing the bulk of the work\n// ConcreteClass2 says: Implemented Operation1\n// AbstractClass says: But I let subclasses override some operations\n// ConcreteClass2 says: Overridden Hook1\n// AbstractClass says: But I am doing the bulk of the work anyway\n// ConcreteClass2 says: Implemented Operation2\n</code></pre> Use Case Cons When defining the skeleton of an algorithm in a method, deferring some steps to subclasses is needed. Can lead to code duplication if subclasses do not reuse the shared code."},{"location":"design-pattern/#visitor","title":"Visitor","text":"<pre><code>class Visitor {\n  visit(element) {}\n}\nclass Element {\n  accept(visitor) { visitor.visit(this); }\n}\n</code></pre> <pre><code>// Visitor interface\nclass Visitor {\n  visitConcreteElementA(element) {}\n  visitConcreteElementB(element) {}\n}\n\n// ConcreteVisitor1 that implements Visitor\nclass ConcreteVisitor1 extends Visitor {\n  visitConcreteElementA(element) {\n    console.log(`${element.constructor.name} is visited by ConcreteVisitor1`);\n  }\n\n  visitConcreteElementB(element) {\n    console.log(`${element.constructor.name} is visited by ConcreteVisitor1`);\n  }\n}\n\n// ConcreteVisitor2 that implements Visitor\nclass ConcreteVisitor2 extends Visitor {\n  visitConcreteElementA(element) {\n    console.log(`${element.constructor.name} is visited by ConcreteVisitor2`);\n  }\n\n  visitConcreteElementB(element) {\n    console.log(`${element.constructor.name} is visited by ConcreteVisitor2`);\n  }\n}\n\n// Element interface\nclass Element {\n  accept(visitor) {}\n}\n\n// ConcreteElementA that implements Element\nclass ConcreteElementA extends Element {\n  accept(visitor) {\n    visitor.visitConcreteElementA(this);\n  }\n\n  operationA() {\n    console.log('ConcreteElementA operation');\n  }\n}\n\n// ConcreteElementB that implements Element\nclass ConcreteElementB extends Element {\n  accept(visitor) {\n    visitor.visitConcreteElementB(this);\n  }\n\n  operationB() {\n    console.log('ConcreteElementB operation');\n  }\n}\n\n// Client code\nconst elements = [new ConcreteElementA(), new ConcreteElementB()];\nconst visitor1 = new ConcreteVisitor1();\nconst visitor2 = new ConcreteVisitor2();\n\nelements.forEach(element =&gt; {\n  element.accept(visitor1);\n  element.accept(visitor2);\n});\n\n// Output:\n// ConcreteElementA is visited by ConcreteVisitor1\n// ConcreteElementB is visited by ConcreteVisitor1\n// ConcreteElementA is visited by ConcreteVisitor2\n// ConcreteElementB is visited by ConcreteVisitor2\n</code></pre> Use Case Cons When performing operations on elements of an object structure without changing the classes on which it operates. Adding new element classes can be difficult. <p>Home</p>"},{"location":"web-performance/","title":"\ud83d\ude80 Web performance","text":"<p>Home</p>"},{"location":"web-security/","title":"\ud83d\udd10 Web security","text":""},{"location":"web-security/#summary","title":"Summary","text":"<p>By adhering to these best practices, you can significantly enhance the security of your frontend application and protect against a wide range of attacks. Remember that security is an ongoing process, and regular audits and updates are essential to maintaining a secure application.</p> <pre><code>- Input Sanitize\n- Prevent Cross-Site-Scripting XSS\n- Add Content security policy CSP (via headers)\n- Prevent Cross-Site-Request-Forgery CSRF (with csrf tokens)\n- Always use HTTPs and WSS (secure only)\n- Cookies with sameSite and secure \n- Evaluate third party dependencies in regular interval\n- IFrame - X-Frame-Options (to block embedding your site) \n- IFrame - frame-ancestors in CSP (to block embedding your site)\n- Secure client side logic and proper error handling\n</code></pre>"},{"location":"web-security/#1-input-validation-and-sanitization","title":"1. Input Validation and Sanitization","text":"<ul> <li>Validate Input: Always validate user input on the client side, though remember that client-side validation is not a substitute for server-side validation.</li> <li>Sanitize Input: Remove or encode potentially harmful characters from user input to prevent injection attacks like Cross-Site Scripting (XSS).</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Input Sanitization Example&lt;/title&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.3.4/purify.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"output\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        function sanitizeInput(input) {\n            return DOMPurify.sanitize(input);\n        }\n\n        const userInput = '&lt;img src=x onerror=alert(\"XSS Attack!\") /&gt;';\n        document.getElementById('output').innerHTML = sanitizeInput(userInput);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#2-cross-site-scripting-xss-prevention","title":"2. Cross-Site Scripting (XSS) Prevention","text":"<ul> <li>Output Encoding: Encode data before rendering it in the HTML to prevent XSS attacks. Use libraries like DOMPurify to sanitize HTML.</li> <li>Avoid <code>eval</code>: Avoid using <code>eval()</code> or similar functions (<code>setTimeout</code>, <code>setInterval</code> with string arguments) which can execute arbitrary code.</li> <li>CSP (Content Security Policy): Implement CSP headers to restrict the sources from which content (scripts, styles, etc.) can be loaded.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;XSS Prevention Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"output\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        function escapeHTML(input) {\n            const div = document.createElement('div');\n            div.appendChild(document.createTextNode(input));\n            return div.innerHTML;\n        }\n\n        const userInput = '&lt;script&gt;alert(\"XSS Attack!\")&lt;/script&gt;';\n        document.getElementById('output').innerHTML = escapeHTML(userInput);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#3-cross-site-request-forgery-csrf-prevention","title":"3. Cross-Site Request Forgery (CSRF) Prevention","text":"<ul> <li>CSRF Tokens: Use CSRF tokens to ensure that requests made on behalf of users are legitimate.</li> <li>SameSite Cookies: Set cookies with the <code>SameSite</code> attribute to prevent them from being sent along with cross-site requests.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;CSRF Prevention Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button id=\"submitBtn\"&gt;Submit&lt;/button&gt;\n    &lt;script&gt;\n        document.getElementById('submitBtn').addEventListener('click', () =&gt; {\n            const csrfToken = 'your-csrf-token';\n\n            fetch('/your-api-endpoint', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'CSRF-Token': csrfToken\n                },\n                body: JSON.stringify({ data: 'example data' })\n            }).then(response =&gt; {\n                if (response.ok) {\n                    return response.json();\n                }\n                throw new Error('Network response was not ok.');\n            }).then(data =&gt; {\n                console.log(data);\n            }).catch(error =&gt; {\n                console.error('There has been a problem with your fetch operation:', error);\n            });\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":"<ul> <li>Use Secure Authentication Methods: Implement strong authentication mechanisms (e.g., OAuth, JWT) and ensure that passwords are hashed and salted before storing.</li> <li>Access Control: Implement proper access control checks to ensure users can only access resources they are authorized to.</li> </ul>"},{"location":"web-security/#5-secure-communication","title":"5. Secure Communication","text":"<ul> <li>HTTPS: Always use HTTPS to encrypt data transmitted between the client and server. Use HSTS (HTTP Strict Transport Security) to enforce HTTPS.</li> <li>Secure WebSockets: If using WebSockets, ensure they are secure (wss://) to protect against man-in-the-middle attacks.</li> </ul>"},{"location":"web-security/#6-secure-storage","title":"6. Secure Storage","text":"<ul> <li>Avoid Storing Sensitive Data: Avoid storing sensitive data (like passwords or tokens) in local storage or session storage, as they are accessible through JavaScript.</li> <li>Secure Cookies: Store tokens and other sensitive information in cookies with <code>HttpOnly</code> and <code>Secure</code> flags.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Secure Cookie Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        function setSecureCookie(name, value, days) {\n            let expires = '';\n            if (days) {\n                const date = new Date();\n                date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n                expires = '; expires=' + date.toUTCString();\n            }\n            document.cookie = `${name}=${value || ''}${expires}; path=/; Secure; HttpOnly; SameSite=Strict`;\n        }\n\n        setSecureCookie('sessionId', '123456', 7);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#7-third-party-dependencies","title":"7. Third-Party Dependencies","text":"<ul> <li>Review and Monitor Dependencies: Regularly review and update third-party libraries to ensure they do not introduce vulnerabilities.</li> <li>Use Subresource Integrity (SRI): Use SRI to ensure that the content of external scripts and stylesheets has not been tampered with.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;SRI Example&lt;/title&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\"\n            integrity=\"sha384-KyZXEAg3QhqLMpG8r+Knujsl5+5hb7O9l5m5V6zr9bU8pmM/sG4XfrdeL8wo/fFz\"\n            crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        $(document).ready(function() {\n            console.log('jQuery loaded with SRI.');\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#8-error-handling","title":"8. Error Handling","text":"<ul> <li>Generic Error Messages: Avoid displaying detailed error messages to users. Instead, log errors on the server and show generic messages to users.</li> <li>Catch Errors: Use try-catch blocks and error handling mechanisms to prevent application crashes and exposure of stack traces.</li> </ul>"},{"location":"web-security/#9-clickjacking-protection","title":"9. Clickjacking Protection","text":"<ul> <li>X-Frame-Options: Use the <code>X-Frame-Options</code> header to prevent your site from being embedded in iframes, which can prevent clickjacking attacks.</li> <li>CSP Frame Ancestors: Use the <code>frame-ancestors</code> directive in CSP to control which sites can embed your pages.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com\"&gt;\n    &lt;title&gt;Content Security Policy Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n        $(document).ready(function() {\n            console.log('jQuery is loaded and CSP is in effect.');\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"web-security/#10-secure-client-side-logic","title":"10. Secure Client-Side Logic","text":"<ul> <li>Minify and Obfuscate: Minify and obfuscate JavaScript code to make it harder for attackers to understand and tamper with.</li> <li>Avoid Sensitive Logic on Client Side: Avoid putting sensitive logic or business rules on the client side where they can be easily inspected and manipulated.</li> </ul> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Avoid Eval Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n        // Instead of using eval\n        // let result = eval('2 + 2');\n        // Use function constructors or direct code\n        let result = (function() {\n            return 2 + 2;\n        })();\n        console.log(result); // Output: 4\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Secure Event Handlers Example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;button id=\"submitBtn\"&gt;Submit&lt;/button&gt;\n    &lt;script&gt;\n        document.getElementById('submitBtn').addEventListener('click', () =&gt; {\n            console.log('Button clicked!');\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Home</p>"}]}